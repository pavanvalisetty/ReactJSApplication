{"ast":null,"code":"import { a as _objectSpread2, _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-1f0bf8c2.js';\nimport { createComponent } from 'reakit-system/createComponent';\nimport { createHook } from 'reakit-system/createHook';\nimport 'reakit-utils/shallowEqual';\nimport { useBox } from '../Box/Box.js';\nimport { useRef, useEffect, useCallback, useMemo } from 'react';\nimport { useForkRef } from 'reakit-utils/useForkRef';\nimport 'reakit-utils/isButton';\nimport { warning, useWarning } from 'reakit-warning';\nimport { useLiveRef } from 'reakit-utils/useLiveRef';\nimport { isSelfTarget } from 'reakit-utils/isSelfTarget';\nimport 'reakit-utils/useIsomorphicEffect';\nimport 'reakit-utils/hasFocusWithin';\nimport 'reakit-utils/isPortalEvent';\nimport 'reakit-utils/getActiveElement';\nimport { canUseDOM } from 'reakit-utils/canUseDOM';\nimport 'reakit-utils/tabbable';\nimport { useTabbable } from '../Tabbable/Tabbable.js';\nimport { useCreateElement } from 'reakit-system/useCreateElement';\nimport { createOnKeyDown } from 'reakit-utils/createOnKeyDown';\nimport { getDocument } from 'reakit-utils/getDocument';\nimport { fireBlurEvent } from 'reakit-utils/fireBlurEvent';\nimport { fireKeyboardEvent } from 'reakit-utils/fireKeyboardEvent';\nimport { getNextActiveElementOnBlur } from 'reakit-utils/getNextActiveElementOnBlur';\nimport { f as flatten, r as reverse, g as groupItems } from '../reverse-30eaa122.js';\nimport { g as getCurrentId, f as findFirstEnabledItem } from '../getCurrentId-5aa9849e.js';\nimport { f as findEnabledItemById } from '../findEnabledItemById-8ddca752.js';\nimport { C as COMPOSITE_KEYS } from '../__keys-6b7fda7f.js';\nvar validCompositeRoles = [\"combobox\", \"grid\", \"tablist\", \"listbox\", \"menu\", \"menubar\", \"toolbar\", \"radiogroup\", \"tree\", \"treegrid\"];\nvar isIE11 = canUseDOM && \"msCrypto\" in window;\n\nfunction canProxyKeyboardEvent(event) {\n  if (!isSelfTarget(event)) return false;\n  if (event.metaKey) return false;\n  if (event.key === \"Tab\") return false;\n  return true;\n}\n\nfunction useKeyboardEventProxy(virtual, currentItem, htmlEventHandler) {\n  var eventHandlerRef = useLiveRef(htmlEventHandler);\n  return useCallback(function (event) {\n    var _eventHandlerRef$curr;\n\n    if (virtual && canProxyKeyboardEvent(event)) {\n      var currentElement = currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current;\n\n      if (currentElement) {\n        fireKeyboardEvent(currentElement, event.type, event); // The event will be triggered on the composite item and then\n        // propagated up to this composite element again, so we can pretend\n        // that it wasn't called on this component in the first place.\n\n        if (event.currentTarget.contains(currentElement)) {\n          event.stopPropagation();\n          event.preventDefault();\n          return;\n        }\n      }\n    }\n\n    (_eventHandlerRef$curr = eventHandlerRef.current) === null || _eventHandlerRef$curr === void 0 ? void 0 : _eventHandlerRef$curr.call(eventHandlerRef, event);\n  }, [virtual, currentItem]);\n} // istanbul ignore next\n\n\nfunction useActiveElementRef(elementRef) {\n  var activeElementRef = useRef(null);\n  useEffect(function () {\n    var document = getDocument(elementRef.current);\n\n    var onFocus = function onFocus(event) {\n      var target = event.target;\n      activeElementRef.current = target;\n    };\n\n    document.addEventListener(\"focus\", onFocus, true);\n    return function () {\n      document.removeEventListener(\"focus\", onFocus, true);\n    };\n  }, []);\n  return activeElementRef;\n}\n\nfunction findFirstEnabledItemInTheLastRow(items) {\n  return findFirstEnabledItem(flatten(reverse(groupItems(items))));\n}\n\nfunction isItem(items, element) {\n  return items === null || items === void 0 ? void 0 : items.some(function (item) {\n    return !!element && item.ref.current === element;\n  });\n}\n\nvar useComposite = createHook({\n  name: \"Composite\",\n  compose: [useTabbable],\n  keys: COMPOSITE_KEYS,\n  useOptions: function useOptions(options) {\n    return _objectSpread2(_objectSpread2({}, options), {}, {\n      currentId: getCurrentId(options)\n    });\n  },\n  useProps: function useProps(options, _ref) {\n    var htmlRef = _ref.ref,\n        htmlOnFocus = _ref.onFocus,\n        htmlOnBlur = _ref.onBlur,\n        htmlOnKeyDown = _ref.onKeyDown,\n        htmlOnKeyUp = _ref.onKeyUp,\n        htmlProps = _objectWithoutPropertiesLoose(_ref, [\"ref\", \"onFocus\", \"onBlur\", \"onKeyDown\", \"onKeyUp\"]);\n\n    var ref = useRef(null);\n    var currentItem = findEnabledItemById(options.items, options.currentId);\n    var previousElementRef = useRef(null);\n    var onFocusRef = useLiveRef(htmlOnFocus);\n    var onBlurRef = useLiveRef(htmlOnBlur); // IE 11 doesn't support event.relatedTarget, so we use the active element\n    // ref instead.\n\n    var activeElementRef = isIE11 ? useActiveElementRef(ref) : undefined;\n    useEffect(function () {\n      var element = ref.current;\n\n      if (!element) {\n        process.env.NODE_ENV !== \"production\" ? warning(true, \"Can't focus composite component because `ref` wasn't passed to component.\", \"See https://reakit.io/docs/composite\") : void 0;\n        return;\n      }\n\n      if (options.unstable_moves && !currentItem) {\n        // If composite.move(null) has been called, the composite container\n        // will receive focus.\n        element.focus();\n      }\n    }, [options.unstable_moves, currentItem]);\n    var onKeyDown = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyDown);\n    var onKeyUp = useKeyboardEventProxy(options.unstable_virtual, currentItem, htmlOnKeyUp);\n    var onFocus = useCallback(function (event) {\n      var _onFocusRef$current2;\n\n      if (options.unstable_virtual) {\n        var currentElement = (currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current) || null; // IE11 doesn't support event.relatedTarget, so we use the active\n        // element ref instead.\n\n        var previousActiveElement = (activeElementRef === null || activeElementRef === void 0 ? void 0 : activeElementRef.current) || event.relatedTarget;\n        var previousActiveElementWasItem = isItem(options.items, previousActiveElement);\n\n        if (isSelfTarget(event) && !previousActiveElementWasItem) {\n          var _onFocusRef$current; // This means that the composite element has been focused while the\n          // composite item has not. For example, by clicking on the\n          // composite element without touching any item, or by tabbing into\n          // the composite element. In this case, we want to trigger focus on\n          // the item, just like it would happen with roving tabindex.\n          // When it receives focus, the composite item will put focus back\n          // on the composite element, in which case hasItemWithFocus will be\n          // true.\n\n\n          (_onFocusRef$current = onFocusRef.current) === null || _onFocusRef$current === void 0 ? void 0 : _onFocusRef$current.call(onFocusRef, event);\n          currentElement === null || currentElement === void 0 ? void 0 : currentElement.focus();\n          return;\n        }\n\n        if (previousActiveElementWasItem) {\n          // Composite has been focused as a result of an item receiving\n          // focus. The composite item will move focus back to the composite\n          // container. In this case, we don't want to propagate this\n          // additional event nor call the onFocus handler passed to\n          // <Composite onFocus={...} /> (htmlOnFocus). Unless users add DOM\n          // event handlers to the composite element directly, this will be\n          // like this event has never existed.\n          event.stopPropagation();\n          return;\n        }\n      } else if (isSelfTarget(event)) {\n        var _options$setCurrentId; // When the roving tabindex composite gets intentionally focused (for\n        // example, by clicking directly on it, and not on an item), we make\n        // sure to set the current id to null (which means the composite\n        // itself is focused).\n\n\n        (_options$setCurrentId = options.setCurrentId) === null || _options$setCurrentId === void 0 ? void 0 : _options$setCurrentId.call(options, null);\n      }\n\n      (_onFocusRef$current2 = onFocusRef.current) === null || _onFocusRef$current2 === void 0 ? void 0 : _onFocusRef$current2.call(onFocusRef, event);\n    }, [options.unstable_virtual, options.items, currentItem, options.setCurrentId]);\n    var onBlur = useCallback(function (event) {\n      var _onBlurRef$current; // When virtual is set to true, we move focus from the composite\n      // container (this component) to the composite item that is being\n      // selected. Then we move focus back to the composite container. This\n      // is so we can provide the same API as the roving tabindex method,\n      // which means people can attach onFocus/onBlur handlers on the\n      // CompositeItem component regardless of whether it's virtual or not.\n      // This sequence of blurring and focusing items and composite may be\n      // confusing, so we ignore intermediate focus and blurs by stopping its\n      // propagation and not calling the passed onBlur handler (htmlOnBlur).\n\n\n      if (options.unstable_virtual) {\n        var currentElement = (currentItem === null || currentItem === void 0 ? void 0 : currentItem.ref.current) || null;\n        var nextActiveElement = getNextActiveElementOnBlur(event);\n        var nextActiveElementIsItem = isItem(options.items, nextActiveElement);\n\n        if (isSelfTarget(event) && nextActiveElementIsItem) {\n          // This is an intermediate blur event: blurring the composite\n          // container to focus an item (nextActiveElement).\n          if (nextActiveElement === currentElement) {\n            // The next active element will be the same as the current item\n            // in the state in two scenarios:\n            //   - Moving focus with keyboard: the state is updated before\n            // the blur event is triggered, so here the current item is\n            // already pointing to the next active element.\n            //   - Clicking on the current active item with a pointer: this\n            // will trigger blur on the composite element and then the next\n            // active element will be the same as the current item. Clicking\n            // on an item other than the current one doesn't end up here as\n            // the currentItem state will be updated only after it.\n            if (previousElementRef.current && previousElementRef.current !== nextActiveElement) {\n              // If there's a previous active item and it's not a click\n              // action, then we fire a blur event on it so it will work just\n              // like if it had DOM focus before (like when using roving\n              // tabindex).\n              fireBlurEvent(previousElementRef.current, event);\n            }\n\n            previousElementRef.current = currentElement;\n          } else if (currentElement) {\n            // This will be true when the next active element is not the\n            // current element, but there's a current item. This will only\n            // happen when clicking with a pointer on a different item, when\n            // there's already an item selected, in which case currentElement\n            // is the item that is getting blurred, and nextActiveElement is\n            // the item that is being clicked.\n            fireBlurEvent(currentElement, event);\n            previousElementRef.current = nextActiveElement;\n          } // We want to ignore intermediate blur events, so we stop its\n          // propagation and return early so onFocus will not be called.\n\n\n          event.stopPropagation();\n          return;\n        }\n\n        var targetIsItem = isItem(options.items, event.target);\n\n        if (!targetIsItem && currentElement) {\n          // If target is not a composite item, it may be the composite\n          // element itself (isSelfTarget) or a tabbable element inside the\n          // composite widget. This may be triggered by clicking outside the\n          // composite widget or by tabbing out of it. In either cases we\n          // want to fire a blur event on the current item.\n          fireBlurEvent(currentElement, event);\n        }\n      }\n\n      (_onBlurRef$current = onBlurRef.current) === null || _onBlurRef$current === void 0 ? void 0 : _onBlurRef$current.call(onBlurRef, event);\n    }, [options.unstable_virtual, options.items, currentItem]);\n    var onMove = useMemo(function () {\n      return createOnKeyDown({\n        onKeyDown: onKeyDown,\n        stopPropagation: true,\n        shouldKeyDown: function shouldKeyDown(event) {\n          return isSelfTarget(event) && options.currentId === null;\n        },\n        keyMap: function keyMap() {\n          var _options$groups;\n\n          var isVertical = options.orientation !== \"horizontal\";\n          var isHorizontal = options.orientation !== \"vertical\";\n          var isGrid = !!((_options$groups = options.groups) === null || _options$groups === void 0 ? void 0 : _options$groups.length);\n\n          var up = function up() {\n            if (isGrid) {\n              var item = findFirstEnabledItemInTheLastRow(options.items);\n\n              if (item === null || item === void 0 ? void 0 : item.id) {\n                var _options$move;\n\n                (_options$move = options.move) === null || _options$move === void 0 ? void 0 : _options$move.call(options, item.id);\n              }\n            } else {\n              var _options$last;\n\n              (_options$last = options.last) === null || _options$last === void 0 ? void 0 : _options$last.call(options);\n            }\n          };\n\n          var first = options.first && function () {\n            return options.first();\n          };\n\n          var last = options.last && function () {\n            return options.last();\n          };\n\n          return {\n            ArrowUp: (isGrid || isVertical) && up,\n            ArrowRight: (isGrid || isHorizontal) && first,\n            ArrowDown: (isGrid || isVertical) && first,\n            ArrowLeft: (isGrid || isHorizontal) && last,\n            Home: first,\n            End: last,\n            PageUp: first,\n            PageDown: last\n          };\n        }\n      });\n    }, [onKeyDown, options.currentId, options.orientation, options.groups, options.items, options.move, options.last, options.first]);\n    return _objectSpread2({\n      ref: useForkRef(ref, htmlRef),\n      id: options.baseId,\n      onFocus: onFocus,\n      onBlur: onBlur,\n      onKeyDown: onMove,\n      onKeyUp: onKeyUp,\n      \"aria-activedescendant\": options.unstable_virtual ? (currentItem === null || currentItem === void 0 ? void 0 : currentItem.id) || undefined : undefined\n    }, htmlProps);\n  },\n  useComposeProps: function useComposeProps(options, htmlProps) {\n    htmlProps = useBox(options, htmlProps, true);\n    var tabbableHTMLProps = useTabbable(options, htmlProps, true);\n\n    if (options.unstable_virtual || options.currentId === null) {\n      // Composite will only be tabbable by default if the focus is managed\n      // using aria-activedescendant, which requires DOM focus on the container\n      // element (the composite)\n      return tabbableHTMLProps;\n    }\n\n    return _objectSpread2(_objectSpread2({}, htmlProps), {}, {\n      ref: tabbableHTMLProps.ref\n    });\n  }\n});\nvar Composite = createComponent({\n  as: \"div\",\n  useHook: useComposite,\n  useCreateElement: function useCreateElement$1(type, props, children) {\n    process.env.NODE_ENV !== \"production\" ? useWarning(!props.role || validCompositeRoles.indexOf(props.role) === -1, \"You should provide a valid `role` attribute to composite components.\", \"See https://reakit.io/docs/composite\") : void 0;\n    process.env.NODE_ENV !== \"production\" ? useWarning(!props[\"aria-label\"] && !props[\"aria-labelledby\"], \"You should provide either `aria-label` or `aria-labelledby` props.\", \"See https://reakit.io/docs/composite\") : void 0;\n    return useCreateElement(type, props, children);\n  }\n});\nexport { Composite, useComposite };","map":null,"metadata":{},"sourceType":"module"}